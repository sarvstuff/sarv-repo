local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))() --VARIABLES-- plr = game.Players.LocalPlayer cam = workspace.CurrentCamera mouse = plr:GetMouse() uis = game:GetService("UserInputService") inv = workspace:WaitForChild(plr.Name.."SpawnedInToys") rs = game:GetService("ReplicatedStorage") rs2 = game:GetService("RunService") deb = game:GetService("Debris") --TOGGLES-- flingT = nil killGrabT = nil infLineExtendT = nil antiGrab1T = nil antiGrab1AnchorT = true antiBlob1T = nil antiExplodeT = true antiLagT = nil antiStickyT = nil blobLoopT = nil walkSpeedT = nil jumpPowerT = nil infJumpT = nil noClipT = nil floatT = nil masslessT = nil blobLoopServerT = nil blobLoopServerTwoHandT = nil silentBlobServerT = nil lagT = nil pingT = nil shurikenLagServerT = nil slideTPT = nil inspectT = false inspectInfoT = false inspectInfoOnT = false ragdollSpamT = false permRagdollT = nil autoGucciT = nil destroyAutoGucciT = nil sitJumpT = false floatUpT = false floatDownT = false zoomT = false spychatT = nil spySelfT = nil publicSpyT = nil --VALUES-- strengthV = 1000 lineDistanceV = 0 increaseLineExtendV = 0 walkSpeedV = 16 jumpPowerV = 24 floatY = -3.1 zoomV = 20 linesV = 400 packetsV = 3000 playersInLoop1V = {} playersInLoop2V = {} --STATUSES-- currentHouseS = 0 blobmanInstanceS = nil currentBlobS = nil currentInspectS = 0 currentHouseInspectS = 0 currentInspectedAdorneeS = nil currentInspectedPartS = nil permRagdollRunningS = false returnPosS = CFrame.new(0, 0, 0) mouseTargetS = nil --DEBS-- infJumpD = false inspectD = false slideTPD = false ragdollSpamD = false ragdollLoopD = false --INSTANCES-- highlight = Instance.new("Highlight") highlight.Name = "highlight" highlight.Enabled = true highlight.FillTransparency = 0.9 highlight.OutlineTransparency = 0 billboard = Instance.new("BillboardGui") billboard.Name = "billboard" billboard.Size = UDim2.new(0, 100, 0, 150) billboard.StudsOffset = Vector3.new(0, 1, 0) billboard.AlwaysOnTop = true scrollframe = Instance.new("ScrollingFrame") scrollframe.Name = "scrollframe" scrollframe.ScrollingEnabled = false scrollframe.BackgroundTransparency = 0.7 textlabel = Instance.new("TextLabel") textlabel.Name = "textlabel" textlabel.TextScaled = true textlabel.BackgroundTransparency = 1 Whitelist = { "SaviorLiberty", "DefyEventHelper1", "DefyEventHelper2", "Defiant_Alt", "R0tationCurveKey", "R0tationCurve", } --GENERALFUNCS-- function updateCurrentBlobmanF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") for _, blobs in workspace:GetDescendants() do if blobs.Name ~= "CreatureBlobman" then continue end if not blobs:FindFirstChild("VehicleSeat") then continue end if not blobs.VehicleSeat:FindFirstChild("SeatWeld") then continue end if blobs.VehicleSeat.SeatWeld.Part1 == hrp then currentBlobS = blobs end end end function blobGrabF(blob, target, side) local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") local args = { [1] = blob:FindFirstChild(side.."Detector"), [2] = target, [3] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"), } blob.BlobmanSeatAndOwnerScript.CreatureGrab:FireServer(unpack(args)) end function blobDropF(blob, target, side) local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") local args = { [1] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"), [2] = target, } blob.BlobmanSeatAndOwnerScript.CreatureDrop:FireServer(unpack(args)) end function updateCurrentHouseF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") if char.Parent == workspace then currentHouseS = 0 elseif char.Parent.Name == "PlayersInPlots" then for i, e in workspace.Plots:GetChildren() do for i, e in e.PlotSign.ThisPlotsOwners:GetChildren() do if e.Value == plr.Name then if e.Parent.Parent.Parent.Name == "Plot1" then currentHouseS = 1 elseif e.Parent.Parent.Parent.Name == "Plot2" then currentHouseS = 2 elseif e.Parent.Parent.Parent.Name == "Plot3" then currentHouseS = 3 elseif e.Parent.Parent.Parent.Name == "Plot4" then currentHouseS = 4 elseif e.Parent.Parent.Parent.Name == "Plot5" then currentHouseS = 5 end end end end end end function mouseTargetInspectF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") if mouse.Target then if mouse.Target.Parent:FindFirstChildOfClass("Humanoid") then currentInspectS = 1 currentHouseInspectS = 0 elseif mouse.Target.Parent:IsDescendantOf(workspace.Plots) then local current = mouse.Target repeat current = current.Parent until string.match(current.Name, "Plot") for i = 1, 5 do if current.Name == "Plot"..i then currentHouseInspectS = i end end currentInspectS = 2 elseif mouse.Target.Parent:IsDescendantOf(workspace.PlotItems) or string.match(mouse.Target.Parent.Parent.Name, "SpawnedInToys") or mouse.Target.Parent.Parent:FindFirstChild("SpawningPlatform") then currentInspectS = 3 currentHouseInspectS = 0 else currentInspectS = 4 currentHouseInspectS = 0 end end end --GRABFUNCS-- function flingF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") workspace.ChildAdded:Connect(function(model) if model.Name == "GrabParts" then local part_to_impulse = model["GrabPart"]["WeldConstraint"].Part1 if part_to_impulse then model:GetPropertyChangedSignal("Parent"):Connect(function() if not model.Parent and flingT then uis.InputBegan:Connect(function(inp, chat) if inp.UserInputType == Enum.UserInputType.MouseButton2 then local velocityObj = Instance.new("BodyVelocity", part_to_impulse) velocityObj.MaxForce = Vector3.new(math.huge, math.huge, math.huge) velocityObj.Velocity = cam.CFrame.lookVector * strengthV deb:AddItem(velocityObj, 1) end end) end end) end end end) end function killGrabF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") workspace.ChildAdded:Connect(function(e) if e.Name == "GrabParts" and killGrabT and e.GrabPart.WeldConstraint.Part1.Parent.Name ~= char.Name and not table.find(Whitelist, e.GrabPart.WeldConstraint.Part1.Parent.Name) then e.GrabPart.WeldConstraint.Part1.Parent:FindFirstChildOfClass("Humanoid").RigType = Enum.RigType.R15 end end) end function infLineExtendF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") uis.InputChanged:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseWheel then if lineDistanceV < 11 then lineDistanceV = 11 end if input.Position.Z > 0 then lineDistanceV = lineDistanceV + increaseLineExtendV elseif input.Position.Z < 0 then lineDistanceV = lineDistanceV - increaseLineExtendV end end end) workspace.ChildAdded:Connect(function(child) if child.Name == "GrabParts" and child:IsA("Model") then if infLineExtendT and uis.MouseEnabled then local grabPartsModel = child grabPartsModel:WaitForChild("GrabPart") grabPartsModel:WaitForChild("DragPart") local clonedDragPart = grabPartsModel.DragPart:Clone() clonedDragPart.Name = "DragPart1" clonedDragPart.AlignPosition.Attachment1 = clonedDragPart.DragAttach clonedDragPart.Parent = grabPartsModel lineDistanceV = (clonedDragPart.Position - cam.CFrame.Position).Magnitude clonedDragPart.AlignOrientation.Enabled = false grabPartsModel.DragPart.AlignPosition.Enabled = false task.spawn(function() while grabPartsModel.Parent do clonedDragPart.Position = cam.CFrame.Position + cam.CFrame.LookVector * lineDistanceV task.wait() end lineDistanceV = 0 end) end end end) end --ANTIFUNCS-- function antiGrab1F() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") while antiGrab1T and task.wait() do if plr.IsHeld.Value == true and antiGrab1T == true then if hrp ~= nil then if antiGrab1AnchorT then hrp.Anchored = true while plr.IsHeld.Value == true do rs.CharacterEvents.Struggle:FireServer(plr);wait(0.001) end hrp.Anchored = false elseif not antiGrab1AnchorT then while plr.IsHeld.Value == true do rs.CharacterEvents.Struggle:FireServer(plr);wait(0.001) end end end end end end function antiBlob1F() workspace.DescendantAdded:Connect(function(toy) if toy.Name == "CreatureBlobman" and toy.Parent ~= inv and antiBlob1T then wait() toy.LeftDetector:Destroy() toy.RightDetector:Destroy() end end) end function antiExplodeF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") workspace.ChildAdded:Connect(function(model) if model.Name == "Part" and char ~= nil and antiExplodeT then local mag = (model.Position - hrp.Position).Magnitude if mag <= 20 then hrp.Anchored = true wait(0.01) while char["Right Arm"].RagdollLimbPart.CanCollide == true do wait(0.001) end hrp.Anchored = false end end end) end function antiLagF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") if antiLagT == true then plr.PlayerScripts.CharacterAndBeamMove.Disabled = true elseif antiLagT == false then plr.PlayerScripts.CharacterAndBeamMove.Enabled = true end end function antiStickyF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") if antiStickyT == true then plr.PlayerScripts.StickyPartsTouchDetection.Disabled = true elseif antiStickyT == false then plr.PlayerScripts.StickyPartsTouchDetection.Enabled = true end end --LOOPFUNCS-- function getPlayerList() local playerList = {} for _, p in pairs(game.Players:GetPlayers()) do if p ~= plr and (p.Name ~= "SaviorLiberty" or p.Name ~= "R0tationCurveKey") then table.insert(playerList, p.Name .. " (" .. p.DisplayName .. ")") end end return playerList end function loopPlayerBlobF() updateCurrentBlobmanF() for i, e in ipairs(playersInLoop2V) do local player if game.Players:FindFirstChild(e) then player = game.Players:FindFirstChild(e) else continue end if blobLoopT then blobGrabF(currentBlobS, player.Character:WaitForChild("HumanoidRootPart"), "Left") wait(0.05) blobDropF(currentBlobS, player.Character:WaitForChild("HumanoidRootPart"), "Left") wait(0.05) silentBlobGrabF(currentBlobS, player.Character:WaitForChild("HumanoidRootPart"), "Left") end end while task.wait(6.25) and blobLoopT do for i, e in ipairs(playersInLoop2V) do local player if game.Players:FindFirstChild(e) then player = game.Players:FindFirstChild(e) else continue end blobGrabF(currentBlobS, player.Character:WaitForChild("HumanoidRootPart"), "Left") wait(0.05) blobDropF(currentBlobS, player.Character:WaitForChild("HumanoidRootPart"), "Left") wait(0.05) silentBlobGrabF(currentBlobS, player.Character:WaitForChild("HumanoidRootPart"), "Left") end end end --PLAYERFUNCS-- function updateWalkSpeedF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") if walkSpeedT then hum.WalkSpeed = walkSpeedV elseif not walkSpeedT then hum.WalkSpeed = 16 end hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function() if walkSpeedT then hum.WalkSpeed = walkSpeedV elseif not walkSpeedT then hum.WalkSpeed = 16 end end) end function updateJumpPowerF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") if jumpPowerT then hum.JumpPower = jumpPowerV elseif not jumpPowerT then hum.JumpPower = 24 end end function updateNoClipF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") while noClipT and task.wait(0.1) do char.Head.CanCollide = false char.Torso.CanCollide = false end if not noClipT then char.Head.CanCollide = true char.Torso.CanCollide = true end end function updateInfJumpF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") uis.JumpRequest:Connect(function() if infJumpT and not infJumpD then infJumpD = true hum:ChangeState(Enum.HumanoidStateType.Jumping) wait() infJumpD = false end end) end function updateFloatF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") if floatT then local float = Instance.new('Part') float.Name = "floatPart" float.Parent = char float.Transparency = 1 float.Size = Vector3.new(2,0.2,1.5) float.Anchored = true float.CFrame = hrp.CFrame * CFrame.new(0, floatY, 0) local function floatLoop() if char:FindFirstChild("floatPart") and hrp then float.CFrame = hrp.CFrame * CFrame.new(0, floatY, 0) end end floatFunc = rs2.Heartbeat:Connect(floatLoop) elseif not floatT then if char:FindFirstChild("floatPart") then char:FindFirstChild("floatPart"):Destroy() end end end function masslessF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") for i, e in char:GetChildren() do if e:IsA("BasePart") and masslessT then e.Massless = true elseif e:IsA("BasePart") and not masslessT then e.Massless = false end end end --SERVERFUNCS-- function updateBlobLoopServerF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") updateCurrentBlobmanF() for i, e in game.Players:GetPlayers() do if e.Character:FindFirstChild("HumanoidRootPart") == nil then continue end if e.Character:FindFirstChild("HumanoidRootPart") and hum then if currentBlobS ~= nil and blobLoopServerT then blobGrabF(currentBlobS, e.Character:WaitForChild("HumanoidRootPart"), "Left") wait(0.05) blobDropF(currentBlobS, e.Character:WaitForChild("HumanoidRootPart"), "Left") wait(0.05) silentBlobGrabF(currentBlobS, e.Character:WaitForChild("HumanoidRootPart"), "Left") end end end while blobLoopServerT and task.wait(6.25) do for i, e in game.Players:GetPlayers() do if e.Character:FindFirstChild("HumanoidRootPart") == nil then continue end if e.Character:FindFirstChild("HumanoidRootPart") and hum then if currentBlobS ~= nil and blobLoopServerT then blobGrabF(currentBlobS, e.Character:WaitForChild("HumanoidRootPart"), "Left") wait(0.05) blobDropF(currentBlobS, e.Character:WaitForChild("HumanoidRootPart"), "Left") wait(0.05) silentBlobGrabF(currentBlobS, e.Character:WaitForChild("HumanoidRootPart"), "Left") end end end end end function lagF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") for i, e in game.Players:GetPlayers() do if table.find(Whitelist, e.Name) then return end end while wait(1) and lagT do for a = 0, linesV do for _, player in ipairs(game:GetService("Players"):GetPlayers()) do if player.Character.Torso ~= nil then rs.GrabEvents.CreateGrabLine:FireServer(player.Character.Torso, player.Character.Torso.CFrame) end end end end end function pingF() for i, e in game.Players:GetPlayers() do if table.find(Whitelist, p.Name) then return end end local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") while task.wait() and pingT do rs.GrabEvents.ExtendGrabLine:FireServer(string.rep("Balls Balls Balls Balls", packetsV)) end end function shurikenLagServerF() for i, e in game.Players:GetPlayers() do if table.find(Whitelist, p.Name) then return end end local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") if shurikenLagServerT then local ToyFolder for _, v in pairs(workspace.Plots:GetChildren()) do for _, b in pairs(v.PlotSign.ThisPlotsOwners:GetChildren()) do if b.Value == plr.Name then ToyFolder = workspace.PlotItems[v.Name] end end end local decoys = {} local shurikens = {} for _, obj in pairs(ToyFolder:GetChildren()) do if obj:IsA("Model") then if obj.Name == "NpcRobloxianMascot" then table.insert(decoys, obj) elseif obj.Name == "NinjaShuriken" then table.insert(shurikens, obj) end end end local maxshurikensperdecoy = 8 for decoyindex, decoy in ipairs(decoys) do local decoyHRP = decoy:FindFirstChild("HumanoidRootPart") if decoyHRP and shurikenLagServerT then local startindex = (decoyindex - 1) * maxshurikensperdecoy + 1 local endindex = startindex + maxshurikensperdecoy - 1 for shurikenindex = startindex, endindex do local shuriken = shurikens[shurikenindex] if not shuriken then break end local StickyPart = shuriken:FindFirstChild("StickyPart") if StickyPart then StickyPart.CanTouch = true for _, part in pairs(decoy:GetDescendants()) do if part:IsA("BasePart") then part.CanCollide = false end end local BodyPosition = Instance.new("BodyPosition") BodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge) BodyPosition.P = 10000 BodyPosition.D = 500 BodyPosition.Parent = StickyPart for _, part in pairs(shuriken:GetDescendants()) do if part:IsA("BasePart") then part.CanCollide = false end end for _, child in pairs(StickyPart:GetChildren()) do if child.Name == "TouchInterest" then child:Destroy() end end task.defer(function() repeat StickyPart.AssemblyAngularVelocity = Vector3.new( math.random(-100, 100) * 50, math.random(-100, 100) * 50, math.random(-100, 100) * 50 ) BodyPosition.Position = Vector3.new( decoyHRP.Position.X, decoyHRP.Position.Y - 4, decoyHRP.Position.Z ) wait(0.0001) BodyPosition.Position = Vector3.new( decoyHRP.Position.X, decoyHRP.Position.Y + 3, decoyHRP.Position.Z ) wait(0.0001) until not shurikenLagServerT or not shuriken.Parent or not decoy.Parent end) end wait() end end wait() end end end --KEYBINDFUNCS-- function tpF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") if not slideTPT then if char and hrp and mouse.Target and not slideTPT then hrp.CFrame = CFrame.new(mouse.Hit.x, mouse.Hit.y + 5, mouse.Hit.z) end elseif slideTPT then if not slideTPD and slideTPT and mouse.Target then slideTPD = true local info = TweenInfo.new( 0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0 ) local info2 = TweenInfo.new( 0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, true, 0 ) local e = {["CFrame"] = CFrame.new(mouse.Hit.x, mouse.Hit.y + 3, mouse.Hit.z)} local e2 = {FieldOfView = 100} char.Head.CanCollide = false char.Torso.CanCollide = false game:GetService("TweenService"):Create(hrp, info, e):Play() game:GetService("TweenService"):Create(cam, info2, e2):Play() wait(0.55) char.Head.CanCollide = true char.Torso.CanCollide = true cam.FieldOfView = 70 slideTPD = false end end end function floatUpF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") if floatUpT and not floatDownT then floatY = -1.6 elseif not floatUpT then floatY = -3.1 end end function floatDownF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") if floatDownT and not floatUpT then floatY = -3.6 elseif not floatDownT then floatY = -3.1 end end function inspectF() local char = plr.Character local hrp = char:WaitForChild("HumanoidRootPart") local hum = char:WaitForChild("Humanoid") mouseTargetInspectF() inspectInfoF() if not inspectD then inspectD = true if inspectT then if currentInspectS == 1 then currentInspectedAdorneeS = mouse.Target.Parent currentInspectedPartS = mouse.Target highlightC = highlight:Clone() highlightC.Adornee = mouse.Target.Parent highlightC.Parent = mouse.Target highlightC.FillColor = Color3.fromRGB(255, 255, 255) highlightC.OutlineColor = Color3.fromRGB(160, 11, 11) elseif currentInspectS == 2 then currentInspectedAdorneeS = workspace.Plots:FindFirstChild("Plot"..currentHouseInspectS) currentInspectedPartS = mouse.Target highlightC = highlight:Clone() highlightC.Adornee = workspace.Plots:FindFirstChild("Plot"..currentHouseInspectS) highlightC.Parent = mouse.Target highlightC.FillColor = Color3.fromRGB(255, 255, 255) highlightC.OutlineColor = Color
